class IntThirtyTwo {
  // When adding multiplication and division, will need a bunch of 
  // precomputed powers of two
  static int bias;
  field int value_lo;
  field int value_hi;

  function void init() {
    let bias = 32767;
    let bias = -bias;
    let bias = bias - 1;
    return;
  }

  constructor IntThirtyTwo new(int hi, int lo) {
    let this = Memory.alloc(2);
    let value_lo = lo;
    let value_hi = hi;
    return this;
  }

  method int lo() {
    return value_lo;
  }

  method int hi() {
    return value_hi;
  }

  method void setHi(int hi) {
    let value_hi = hi;
  }

  method void setLo(int lo) {
    let value_lo = lo;
  }

  function void add(IntThirtyTwo sum, IntThirtyTwo a, IntThirtyTwo b) {
    var int a_lo, b_lo, a_hi, b_hi, sum_lo, sum_hi;
    var int a_lo_bias, sum_lo_bias;
    // first, add the low bits
    let a_lo = a.lo();
    let b_lo = b.lo();
    let a_hi = a.hi();
    let b_hi = b.hi();
    let sum_lo = a_lo + b_lo;

    // Get carry out
    // We would normally want unsigned compare to check for carry, but
    // we only have signed compare. We can do unsigned compare by
    // biasing by 0x8000 = -32768, stored as static variable bias
    
    let a_lo_bias = a_lo + bias;
    let sum_lo_bias = sum_lo + bias;    

    // add high portions
    let sum_hi = a_hi + b_hi;

    // if carry, add 1 to the result
    if (sum_lo_bias < a_lo_bias) {
      let sum_hi = sum_hi + 1;
    }

    do sum.setHi(sum_hi);
    do sum.setLo(sum_lo);
    return;
  }

  function void neg(IntThirtyTwo minus_a, IntThirtyTwo a) {
    var int lo, hi;
    let lo = a.lo();
    let hi = a.hi();
    let lo = (~lo);
    let hi = (~hi);
    let lo = lo + 1;
    if (lo = 0) {
      // carry
      let hi = hi + 1;
    }
    
    do minus_a.setHi(hi);
    do minus_a.setLo(lo);
    return;
  }

  function void sub(IntThirtyTwo diff, IntThirtyTwo a, IntThirtyTwo b) {
    var IntThirtyTwo minus_b;
    let minus_b = IntThirtyTwo.new(0, 0);
    do IntThirtyTwo.neg(minus_b, b);
    do IntThirtyTwo.add(diff, a, minus_b);
    do minus_b.dispose();
    return;
  }

  function void from_int(IntThirtyTwo x_thirty_two, int x) {
    var int lo, hi;
    let lo = x;
    if (x < 0) {
      let hi = -1;
    } else {
      let hi = 0;
    }
    do x_thirty_two.setHi(hi);
    do x_thirty_two.setLo(lo);
    return;
  }

  // This function makes no effort to handle signs; use it only with
  // nonnegative 32-bit integers
  function void unsigned_multiply(IntThirtyTwo product, IntThirtyTwo x, IntThirtyTwo y) {
    var IntThirtyTwo two_to_the_i;        
    var IntThirtyTwo shifted_x;
    var int i, ith_bit_of_y_hi, ith_bit_of_y_lo, y_hi, y_lo;

    let i = 0;
    do product.setHi(0);
    do product.setLo(0);
    let shifted_x = IntThirtyTwo.new(x.hi(), x.lo());
    let two_to_the_i = IntThirtyTwo.new(0,1);
    let y_hi = y.hi();
    let y_lo = y.lo();

    while (i < 32) {
      let ith_bit_of_y_hi = (two_to_the_i.hi()) & (y_hi);
      let ith_bit_of_y_lo = (two_to_the_i.lo()) & (y_lo);

      if ((~(ith_bit_of_y_hi = 0)) | (~(ith_bit_of_y_lo = 0))) {
        do IntThirtyTwo.add(product, product, shifted_x);
      }

      do IntThirtyTwo.add(shifted_x, shifted_x, shifted_x);
      do IntThirtyTwo.add(two_to_the_i, two_to_the_i, two_to_the_i);
      let i = i + 1;
    }

    do shifted_x.dispose();
    do two_to_the_i.dispose();

    return;
  }

  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }
}
