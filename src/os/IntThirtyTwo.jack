class IntThirtyTwo {
  // When adding multiplication and division, will need a bunch of 
  // precomputed powers of two
  static int bias;
  field int value_lo;
  field int value_hi;

  function void init() {
    let bias = 32767;
    let bias = -bias;
    let bias = bias - 1;
    return;
  }

  constructor IntThirtyTwo new(int hi, int lo) {
    let this = Memory.alloc(2);
    let value_lo = lo;
    let value_hi = hi;
    return this;
  }

  method int lo() {
    return value_lo;
  }

  method int hi() {
    return value_hi;
  }

  method void setHi(int hi) {
    let value_hi = hi;
  }

  method void setLo(int lo) {
    let value_lo = lo;
  }

  function boolean ultSixteen(int a, int b) {
    if ((a + bias) < (b + bias)) {
      return true;
    }
    return false;
  }

  function boolean ugtSixteen(int a, int b) {
    return IntThirtyTwo.ultSixteen(b, a);
  }

  function boolean ult(IntThirtyTwo a, IntThirtyTwo b) {
    // Unsigned compare
    // Strategy: first, compare high halves
    // If high halves are equal, compare low halves
    var int a_hi, b_hi, a_lo, b_lo;
    let a_hi = a.hi();
    let b_hi = b.hi();
    if (IntThirtyTwo.ultSixteen(a_hi, b_hi)) {
      return true;
    }
    if (IntThirtyTwo.ultSixteen(b_hi, a_hi)) {
      return false;
    }
    let a_lo = a.lo();
    let b_lo = b.lo();
    if (IntThirtyTwo.ultSixteen(a_lo, b_lo)) {
      return true;
    } 
    return false;
  }

  function boolean ugt(IntThirtyTwo a, IntThirtyTwo b) {
    return IntThirtyTwo.ult(b, a);
  }

  function boolean eq(IntThirtyTwo a, IntThirtyTwo b) {
    var int a_hi, a_lo, b_hi, b_lo;
    let a_hi = a.hi();
    let b_hi = b.hi();
    if (a_hi = b_hi) {
      let a_lo = a.lo();
      let b_lo = b.lo();
      if (a_lo = b_lo) {
        return true;
      }
    }
    return false;
  }

  function void add(IntThirtyTwo sum, IntThirtyTwo a, IntThirtyTwo b) {
    var int a_lo, b_lo, a_hi, b_hi, sum_lo, sum_hi;
    // first, add the low bits
    let a_lo = a.lo();
    let b_lo = b.lo();
    let a_hi = a.hi();
    let b_hi = b.hi();
    let sum_lo = a_lo + b_lo;

    // add high portions
    let sum_hi = a_hi + b_hi;

    // if carry, add 1 to the result
    // Note: if the sum is (unsigned compare) < either addend, overflow,
    // so carry
    if (IntThirtyTwo.ultSixteen(sum_lo, a_lo)) {
      let sum_hi = sum_hi + 1;
    }

    do sum.setHi(sum_hi);
    do sum.setLo(sum_lo);
    return;
  }

  function void neg(IntThirtyTwo minus_a, IntThirtyTwo a) {
    var int lo, hi;
    let lo = a.lo();
    let hi = a.hi();
    let lo = (~lo);
    let hi = (~hi);
    let lo = lo + 1;
    if (lo = 0) {
      // carry
      let hi = hi + 1;
    }
    
    do minus_a.setHi(hi);
    do minus_a.setLo(lo);
    return;
  }

  // Minus_b is a temporary. It should not alias other variables passed in to this function.
  function void sub(IntThirtyTwo diff, IntThirtyTwo minus_b, IntThirtyTwo a, IntThirtyTwo b) {
    do IntThirtyTwo.neg(minus_b, b);
    do IntThirtyTwo.add(diff, a, minus_b);
    return;
  }

  function void from_int(IntThirtyTwo x_thirty_two, int x) {
    var int lo, hi;
    let lo = x;
    if (x < 0) {
      let hi = -1;
    } else {
      let hi = 0;
    }
    do x_thirty_two.setHi(hi);
    do x_thirty_two.setLo(lo);
    return;
  }

  // This function makes no effort to handle signs; use it only with
  // nonnegative 32-bit integers
  // Note: shifted_x and two_to_the_i are temporaries. Pass them in so as not to have to allocate on each call.
  // They should not alias other variables passed in here.
  function void unsigned_multiply(IntThirtyTwo product, IntThirtyTwo x, IntThirtyTwo y, IntThirtyTwo shifted_x, IntThirtyTwo two_to_the_i) {
    var int i, ith_bit_of_y_hi, ith_bit_of_y_lo, y_hi, y_lo;

    let i = 0;
    do product.setHi(0);
    do product.setLo(0);
    do shifted_x.setHi(x.hi());
    do shifted_x.setLo(x.lo());
    do two_to_the_i.setHi(0);
    do two_to_the_i.setLo(1);
    let y_hi = y.hi();
    let y_lo = y.lo();

    while (i < 32) {
      let ith_bit_of_y_hi = (two_to_the_i.hi()) & (y_hi);
      let ith_bit_of_y_lo = (two_to_the_i.lo()) & (y_lo);

      if ((~(ith_bit_of_y_hi = 0)) | (~(ith_bit_of_y_lo = 0))) {
        do IntThirtyTwo.add(product, product, shifted_x);
      }

      do IntThirtyTwo.add(shifted_x, shifted_x, shifted_x);
      do IntThirtyTwo.add(two_to_the_i, two_to_the_i, two_to_the_i);
      let i = i + 1;
    }

    return;
  }

  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }
}
