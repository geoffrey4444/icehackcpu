class IntThirtyTwo {
  // When adding multiplication and division, will need a bunch of 
  // precomputed powers of two
  static int bias;
  field int value_lo;
  field int value_hi;

  function void init() {
    let bias = 32767;
    let bias = -bias;
    let bias = bias - 1;
    return;
  }

  constructor IntThirtyTwo new(int hi, int lo) {
    let this = Memory.alloc(2);
    let value_lo = lo;
    let value_hi = hi;
    return this;
  }

  method int lo() {
    return value_lo;
  }

  method int hi() {
    return value_hi;
  }

  method void setHi(int hi) {
    let value_hi = hi;
  }

  method void setLo(int lo) {
    let value_lo = lo;
  }

  function boolean ultSixteen(int a, int b) {
    if ((a + bias) < (b + bias)) {
      return true;
    }
    return false;
  }

  function boolean ugtSixteen(int a, int b) {
    return IntThirtyTwo.ultSixteen(b, a);
  }

  function boolean ult(IntThirtyTwo a, IntThirtyTwo b) {
    // Unsigned compare
    // Strategy: first, compare high halves
    // If high halves are equal, compare low halves
    var int a_hi, b_hi, a_lo, b_lo;
    let a_hi = a.hi();
    let b_hi = b.hi();
    if (IntThirtyTwo.ultSixteen(a_hi, b_hi)) {
      return true;
    }
    if (IntThirtyTwo.ultSixteen(b_hi, a_hi)) {
      return false;
    }
    let a_lo = a.lo();
    let b_lo = b.lo();
    if (IntThirtyTwo.ultSixteen(a_lo, b_lo)) {
      return true;
    } 
    return false;
  }

  function boolean ugt(IntThirtyTwo a, IntThirtyTwo b) {
    return IntThirtyTwo.ult(b, a);
  }

  function boolean eq(IntThirtyTwo a, IntThirtyTwo b) {
    var int a_hi, a_lo, b_hi, b_lo;
    let a_hi = a.hi();
    let b_hi = b.hi();
    if (a_hi = b_hi) {
      let a_lo = a.lo();
      let b_lo = b.lo();
      if (a_lo = b_lo) {
        return true;
      }
    }
    return false;
  }

  function void add(IntThirtyTwo sum, IntThirtyTwo a, IntThirtyTwo b) {
    var int a_lo, b_lo, a_hi, b_hi, sum_lo, sum_hi;
    // first, add the low bits
    let a_lo = a.lo();
    let b_lo = b.lo();
    let a_hi = a.hi();
    let b_hi = b.hi();
    let sum_lo = a_lo + b_lo;

    // add high portions
    let sum_hi = a_hi + b_hi;

    // if carry, add 1 to the result
    // Note: if the sum is (unsigned compare) < either addend, overflow,
    // so carry
    if (IntThirtyTwo.ultSixteen(sum_lo, a_lo)) {
      let sum_hi = sum_hi + 1;
    }

    do sum.setHi(sum_hi);
    do sum.setLo(sum_lo);
    return;
  }

  function void neg(IntThirtyTwo minus_a, IntThirtyTwo a) {
    var int lo, hi;
    let lo = a.lo();
    let hi = a.hi();
    let lo = (~lo);
    let hi = (~hi);
    let lo = lo + 1;
    if (lo = 0) {
      // carry
      let hi = hi + 1;
    }
    
    do minus_a.setHi(hi);
    do minus_a.setLo(lo);
    return;
  }

  // Minus_b is a temporary. It should not alias diff, a, or b
  function void sub(IntThirtyTwo diff, IntThirtyTwo minus_b, IntThirtyTwo a, IntThirtyTwo b) {
    do IntThirtyTwo.neg(minus_b, b);
    do IntThirtyTwo.add(diff, a, minus_b);
    return;
  }

  function void from_int(IntThirtyTwo x_thirty_two, int x) {
    var int lo, hi;
    let lo = x;
    if (x < 0) {
      let hi = -1;
    } else {
      let hi = 0;
    }
    do x_thirty_two.setHi(hi);
    do x_thirty_two.setLo(lo);
    return;
  }

  // This function makes no effort to handle signs; use it only with
  // nonnegative 32-bit integers
  // Note: shifted_x and two_to_the_i are temporaries. Pass them in so as not to have to allocate on each call.
  // They should not alias other variables passed in here.
  function void unsigned_multiply(IntThirtyTwo product, IntThirtyTwo x, IntThirtyTwo y, IntThirtyTwo shifted_x, IntThirtyTwo two_to_the_i) {
    var int i, ith_bit_of_y_hi, ith_bit_of_y_lo, y_hi, y_lo;

    let i = 0;
    do product.setHi(0);
    do product.setLo(0);
    do shifted_x.setHi(x.hi());
    do shifted_x.setLo(x.lo());
    do two_to_the_i.setHi(0);
    do two_to_the_i.setLo(1);
    let y_hi = y.hi();
    let y_lo = y.lo();

    while (i < 32) {
      let ith_bit_of_y_hi = (two_to_the_i.hi()) & (y_hi);
      let ith_bit_of_y_lo = (two_to_the_i.lo()) & (y_lo);

      if ((~(ith_bit_of_y_hi = 0)) | (~(ith_bit_of_y_lo = 0))) {
        do IntThirtyTwo.add(product, product, shifted_x);
      }

      do IntThirtyTwo.add(shifted_x, shifted_x, shifted_x);
      do IntThirtyTwo.add(two_to_the_i, two_to_the_i, two_to_the_i);
      let i = i + 1;
    }

    return;
  }

  // Note: temp_a, temp_b, temp_c, and temp_d are temporaries and must not alias each other or quotient
  function void unsigned_divide_recursive(IntThirtyTwo quotient, int x_hi, int x_lo, int y_hi, int y_lo, IntThirtyTwo temp_a, IntThirtyTwo temp_b, IntThirtyTwo temp_c, IntThirtyTwo temp_d) {
    var int two_y_hi, two_y_lo;

    // Cannot divide by zero; halt if user attempts thi
    if ((y_lo = 0) & (y_hi = 0)) {
      do Output.printString("error: unsigned divide by zero\n\r");
      do Sys.halt();
    }

    // Checks that let us return 0 right away
    // temp_a = x, temp_b = y
    do temp_a.setHi(x_hi);
    do temp_a.setLo(x_lo);
    do temp_b.setHi(y_hi);
    do temp_b.setLo(y_lo);

    if (((x_hi = 0) & (x_lo = 0)) | (IntThirtyTwo.ult(temp_a, temp_b))) {
      do quotient.setHi(0);
      do quotient.setLo(0);
      return;
    }

    if (IntThirtyTwo.eq(temp_a, temp_b)) {
      do quotient.setHi(0);
      do quotient.setLo(1);
      return;
    }

    // temp_c = 2 * temp_b = 2 * y
    do IntThirtyTwo.add(temp_c, temp_b, temp_b);
    let two_y_hi = temp_c.hi();
    let two_y_lo = temp_c.lo();

    if (IntThirtyTwo.ult(temp_c, temp_b)) {
      // If 2 * y overflows, then stop recursing. And since the true value
      // of 2 *y must be > x, since it overflowed, return 0.
      do quotient.setHi(0);
      do quotient.setLo(0);
      return;
    }

    // Stop recursion if 2 * y > x ... further recursion will just return 0.
    // x is still in temp_a
    if (IntThirtyTwo.ult(temp_a, temp_c)) {
      do quotient.setHi(0);
      do quotient.setLo(0);
      return;
    }

    // Recursive call... temp_a, temp_b, temp_c values unknown after this call
    // Quotient uninitialized before this call, will have a meaningful value
    // after the call that includes results from all recursions below.
    do IntThirtyTwo.unsigned_divide_recursive(quotient, x_hi, x_lo, two_y_hi, two_y_lo, temp_a, temp_b, temp_c, temp_d);

    // quotient, temp_a = -y (unused temporary in subtraction), 
    // temp_d = y
    // temp_b = q * y
    // Unsigned multiply needs two temporaries, so use temp_a and temp_c
    do temp_d.setHi(y_hi);
    do temp_d.setLo(y_lo);
    do IntThirtyTwo.unsigned_multiply(temp_b, quotient, temp_d, temp_a, temp_c);

    // temp_c = x - q * y - q * y
    do temp_d.setHi(x_hi);
    do temp_d.setLo(x_lo);
    do IntThirtyTwo.sub(temp_c, temp_a, temp_d, temp_b);
    do IntThirtyTwo.sub(temp_c, temp_a, temp_c, temp_b);
    
    do IntThirtyTwo.add(quotient, quotient, quotient);

    do temp_d.setHi(y_hi);
    do temp_d.setLo(y_lo);
    if (~(IntThirtyTwo.ult(temp_c, temp_d))) {
      // temp_a = 1
      do temp_a.setHi(0);
      do temp_a.setLo(1);
      do IntThirtyTwo.add(quotient, quotient, temp_a);
    }
    
    return;
  }

  // Note: temp_a, temp_b, temp_c are temporaries and must not alias each other or x or y or quotient
  // Also: quotient must not alias x or y
  function void unsigned_divide(IntThirtyTwo quotient, IntThirtyTwo x, IntThirtyTwo y, IntThirtyTwo temp_a, IntThirtyTwo temp_b, IntThirtyTwo temp_c, IntThirtyTwo temp_d) {    
    do IntThirtyTwo.unsigned_divide_recursive(quotient, x.hi(), x.lo(), y.hi(), y.lo(), temp_a, temp_b, temp_c, temp_d);

    return;
  }

  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }
}
